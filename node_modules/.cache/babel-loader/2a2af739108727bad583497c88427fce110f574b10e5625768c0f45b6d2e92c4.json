{"ast":null,"code":"var _jsxFileName = \"/Users/gr4yf1r3/testSites/tts-website/src/App.js\",\n  _s = $RefreshSig$();\n// src/App.js\nimport React, { useState, useEffect } from 'react';\nimport { parseXlsx } from './utils'; // Import parseXlsx from utils.js\nimport AudioList from './components/AudioList';\nimport Header from './components/Header';\nimport Footer from './components/Footer';\nimport TtsForm from './components/TtsForm';\nimport ApiKeyInput from './components/ApiKeyInput';\nimport OpenAI from 'openai';\n\n/**\n * OpenAI API Key from environment variables\n * @type {string}\n */\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Validates if a given API key has the correct format\n * @param {string} key - The API key to validate\n * @returns {boolean} - True if the key is valid, false otherwise\n */\nconst isValidApiKey = key => {\n  return key && typeof key === 'string' && key.startsWith('sk-') && key.length > 20;\n};\n\n// Initialize with stored API key if available\nconst storedApiKey = localStorage.getItem('openai_api_key') || apiKey;\n\n/**\n * Initialize OpenAI client - will be re-initialized when API key changes\n */\nlet openai = new OpenAI({\n  apiKey: storedApiKey,\n  dangerouslyAllowBrowser: true // Required for browser usage\n});\n\n/**\n * Main application component\n * Handles text-to-speech generation, excel file processing, and audio file management\n */\nconst App = () => {\n  _s();\n  const [audioFiles, setAudioFiles] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [apiKey, setApiKey] = useState(storedApiKey || '');\n  const [processingProgress, setProcessingProgress] = useState({\n    current: 0,\n    total: 0\n  });\n\n  // Listen for changes to file checkboxes\n  // Listen for changes to file checkboxes\n  useEffect(() => {\n    const handleFileCheckChanged = event => {\n      const {\n        index,\n        checked\n      } = event.detail;\n      setAudioFiles(prev => {\n        const newFiles = [...prev];\n        newFiles[index] = {\n          ...newFiles[index],\n          checked\n        };\n        return newFiles;\n      });\n    };\n    window.addEventListener('fileCheckChanged', handleFileCheckChanged);\n    return () => {\n      window.removeEventListener('fileCheckChanged', handleFileCheckChanged);\n    };\n  }, []);\n\n  // Effect to handle API key changes\n  useEffect(() => {\n    if (apiKey) {\n      // Save to localStorage\n      localStorage.setItem('openai_api_key', apiKey);\n\n      // Re-initialize OpenAI client with new key\n      openai = new OpenAI({\n        apiKey: apiKey,\n        dangerouslyAllowBrowser: true\n      });\n    }\n  }, [apiKey]);\n\n  /**\n   * Handles audio generation from text prompt using OpenAI API\n   * @param {string} prompt - The text prompt to convert to audio\n   * @param {string} persona - The persona or style for the speech (optional)\n   * @param {string} voice - The voice model to use for speech synthesis\n   */\n  const handleGenerateAudio = async (prompt, persona, voice) => {\n    if (!prompt.trim()) {\n      setError(\"Please enter a prompt text\");\n      return;\n    }\n\n    // First check if API key is available and valid\n    if (!apiKey || !apiKey.startsWith('sk-') || apiKey.length < 20) {\n      setError(\"Please enter a valid OpenAI API key. It should start with 'sk-'\");\n      return;\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      console.log(`Generating audio for prompt: \"${prompt}\" with voice: ${voice}`);\n      const response = await openai.audio.speech.create({\n        model: \"tts-1\",\n        voice: voice,\n        input: prompt,\n        instructions: persona || undefined\n      });\n      const audioBlob = await response.blob();\n      const fileName = `${prompt.substring(0, 20).replace(/[^a-zA-Z0-9]/g, '_')}.mp3`;\n      console.log(`Successfully generated audio: ${fileName}`);\n      setAudioFiles(prev => [...prev, {\n        name: fileName,\n        url: audioBlob,\n        prompt: prompt,\n        checked: false\n      }]);\n    } catch (err) {\n      console.error('Error generating speech:', err);\n\n      // More specific error messages based on the error\n      if (err.message && err.message.includes('API key')) {\n        setError(`API key error: ${err.message}. Check your .env file.`);\n      } else if (err.status === 429) {\n        setError(\"Rate limit exceeded. Please try again later.\");\n      } else {\n        setError(`Failed to generate audio: ${err.message || 'Unknown error'}`);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  /**\n   * Handles bulk upload and processing of audio files from selected Excel files\n   * Uses chunking for better performance with large files\n   * @param {FileList} files - The list of Excel files to upload and process\n   */\n  const handleUploadFiles = async files => {\n    setLoading(true);\n    setError(null);\n    setProcessingProgress({\n      current: 0,\n      total: 0\n    });\n\n    // First check if API key is available and valid\n    if (!isValidApiKey(apiKey)) {\n      setError(\"OpenAI API key is missing or invalid. Check your .env file.\");\n      setLoading(false);\n      return;\n    }\n\n    // Track successes and failures\n    let successCount = 0;\n    let failureCount = 0;\n    let totalRowsToProcess = 0;\n\n    // First, calculate total rows across all files for accurate progress tracking\n    for (const file of files) {\n      if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {\n        try {\n          const data = await parseXlsx(file);\n          if (data && data.length > 0) {\n            // Skip header row if it exists\n            const startRow = data[0] && typeof data[0][0] === 'string' && (data[0][0].toLowerCase().includes('prompt') || data[0][0].toLowerCase().includes('text')) ? 1 : 0;\n            totalRowsToProcess += data.length - startRow;\n          }\n        } catch (err) {\n          console.error('Error parsing XLSX file during count:', err);\n        }\n      }\n    }\n\n    // Set the total for progress tracking\n    setProcessingProgress({\n      current: 0,\n      total: totalRowsToProcess\n    });\n    let currentProcessed = 0;\n\n    // Process each file\n    for (const file of files) {\n      if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {\n        try {\n          console.log(`Processing Excel file: ${file.name}`);\n          const data = await parseXlsx(file);\n          if (!data || data.length === 0) {\n            setError(`File \"${file.name}\" appears to be empty.`);\n            continue;\n          }\n          console.log(`Excel data loaded: ${data.length} rows`);\n\n          // Skip header row if it exists\n          const startRow = data[0] && typeof data[0][0] === 'string' && (data[0][0].toLowerCase().includes('prompt') || data[0][0].toLowerCase().includes('text')) ? 1 : 0;\n          console.log(`Starting processing from row ${startRow + 1}`);\n\n          // Process data in chunks to prevent UI freezing with large files\n          const CHUNK_SIZE = 5; // Process 5 rows at a time\n\n          /**\n           * Process a single row of data\n           * @param {number} rowIndex - The index of the row in the data array\n           * @param {Object} openaiClient - The OpenAI client instance\n           * @returns {Promise<Object>} - Promise resolving to a result object\n           */\n          const processRow = async (rowIndex, rowData, rowNumber, openaiClient) => {\n            const promptText = rowData[0] ? String(rowData[0]) : '';\n            let voice = rowData[1] || 'alloy'; // Use column 1 for voice if available\n            const instructions = rowData[2] || ''; // Use column 2 for instructions if available\n\n            // Validate the voice parameter\n            const allowedVoices = ['nova', 'shimmer', 'echo', 'onyx', 'fable', 'alloy', 'ash', 'sage', 'coral'];\n            if (!allowedVoices.includes(voice)) {\n              console.warn(`Invalid voice '${voice}' for row ${rowNumber}. Falling back to default 'alloy'.`);\n              voice = 'alloy';\n            }\n            try {\n              console.log(`Processing row ${rowNumber}: \"${promptText.substring(0, 30)}...\" with voice \"${voice}\"`);\n              const response = await openaiClient.audio.speech.create({\n                model: \"tts-1\",\n                voice: voice,\n                input: promptText,\n                instructions: instructions || undefined\n              });\n              const audioBlob = await response.blob();\n              const fileName = `Row${rowNumber}_${promptText.substring(0, 15).replace(/[^a-zA-Z0-9]/g, '_')}.mp3`;\n              setAudioFiles(prev => [...prev, {\n                name: fileName,\n                url: audioBlob,\n                prompt: promptText,\n                checked: false\n              }]);\n              return {\n                success: true\n              };\n            } catch (err) {\n              console.error(`Error generating speech for row ${rowNumber}:`, err);\n              setAudioFiles(prev => [...prev, {\n                name: `Error_Row${rowNumber}.mp3`,\n                url: null,\n                prompt: `Error with \"${promptText ? promptText.substring(0, 30) : 'Empty prompt'}...\": ${err.message}`,\n                checked: false,\n                error: true\n              }]);\n              return {\n                success: false,\n                error: err\n              };\n            }\n          };\n\n          /**\n           * Process a single chunk of data rows\n           * @param {number} startIndex - The starting index of the chunk\n           * @param {number} endIndex - The ending index of the chunk\n           * @param {object} openaiClient - The OpenAI client instance\n           * @param {function} handleSuccess - Function to call on success\n           * @param {function} handleFailure - Function to call on failure\n           * @param {function} updateProgress - Function to update progress\n           * @returns {Promise<Array>} - Promise resolving to array of results\n           */\n          const processChunk = async (startIndex, endIndex, openaiClient, handleSuccess, handleFailure, updateProgress) => {\n            const promises = [];\n\n            // Create promises for each row in the chunk\n            for (let i = startIndex; i < endIndex && i < data.length; i++) {\n              if (data[i] && data[i][0]) {\n                const rowNumber = i + 1;\n\n                // Create a new promise for this row without referencing loop variables in the closure\n                const processPromise = async () => {\n                  const result = await processRow(i, data[i], rowNumber, openaiClient);\n                  if (result.success) {\n                    handleSuccess(rowNumber);\n                  } else {\n                    handleFailure(rowNumber);\n                  }\n                  updateProgress();\n                  return result;\n                };\n                promises.push(processPromise());\n              }\n            }\n\n            // Wait for all promises in this chunk to complete\n            return Promise.all(promises);\n          };\n\n          // Move function declarations outside the loop and pass variables as parameters\n          const handleSuccessCallback = (rowNumber, successCountRef) => {\n            successCountRef.current++;\n            console.log(`Successfully generated audio for row ${rowNumber}`);\n          };\n          const handleFailureCallback = (rowNumber, failureCountRef) => {\n            failureCountRef.current++;\n          };\n          const updateProgressCallback = (currentProcessedRef, setProcessingProgress) => {\n            currentProcessedRef.current++;\n            setProcessingProgress(prev => ({\n              ...prev,\n              current: currentProcessedRef.current\n            }));\n          };\n\n          // Process chunks sequentially to avoid overwhelming the API\n          for (let i = startRow; i < data.length; i += CHUNK_SIZE) {\n            const successCountRef = {\n              current: successCount\n            };\n            const failureCountRef = {\n              current: failureCount\n            };\n            const currentProcessedRef = {\n              current: currentProcessed\n            };\n            await processChunk(i, i + CHUNK_SIZE, openai, rowNumber => handleSuccessCallback(rowNumber, successCountRef), rowNumber => handleFailureCallback(rowNumber, failureCountRef), () => updateProgressCallback(currentProcessedRef, setProcessingProgress));\n\n            // Update the outer variables after processing\n            successCount = successCountRef.current;\n            failureCount = failureCountRef.current;\n            currentProcessed = currentProcessedRef.current;\n          }\n        } catch (err) {\n          console.error('Error parsing XLSX file:', err);\n          setError(`Failed to parse Excel file: ${err.message || 'Unknown error'}`);\n        }\n      } else {\n        setError(`File \"${file.name}\" is not a valid Excel file.`);\n      }\n    }\n\n    // Show a summary message\n    if (successCount > 0 && failureCount === 0) {\n      setError(null); // Clear any previous errors\n      console.log(`All ${successCount} audio files generated successfully!`);\n    } else if (successCount > 0 && failureCount > 0) {\n      setError(`Generated ${successCount} files successfully, but ${failureCount} failed. Check the list for details.`);\n    } else if (successCount === 0 && failureCount > 0) {\n      setError(`Failed to generate any audio files. Check the console for details.`);\n    }\n    setLoading(false);\n    setProcessingProgress({\n      current: 0,\n      total: 0\n    }); // Reset progress\n  };\n\n  /**\n   * Handles downloading of a single audio file\n   * @param {number} index - The index of the audio file in the list\n   */\n  const handleDownload = index => {\n    const file = audioFiles[index];\n    if (file && file.url) {\n      try {\n        const url = URL.createObjectURL(file.url);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = file.name;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        console.log(`Downloaded file: ${file.name}`);\n      } catch (err) {\n        console.error('Error downloading file:', err);\n        setError(`Failed to download file: ${err.message}`);\n      }\n    } else if (file) {\n      setError(`Cannot download \"${file.name}\" - no audio data available`);\n    }\n  };\n\n  /**\n   * Handles bulk downloading of selected audio files\n   */\n  const handleBulkDownload = () => {\n    const selectedFiles = audioFiles.filter(file => file.checked);\n    if (selectedFiles.length === 0) {\n      // If none selected, download all\n      audioFiles.forEach((file, index) => handleDownload(index));\n    } else {\n      // Download only selected\n      selectedFiles.forEach(file => {\n        const index = audioFiles.indexOf(file);\n        if (index !== -1) handleDownload(index);\n      });\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(Header, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 424,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      children: [/*#__PURE__*/_jsxDEV(ApiKeyInput, {\n        initialApiKey: apiKey,\n        onApiKeyChange: setApiKey\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 426,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(TtsForm, {\n        onGenerateAudio: handleGenerateAudio,\n        onUploadFiles: handleUploadFiles\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 431,\n        columnNumber: 9\n      }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"error-message\",\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 436,\n        columnNumber: 19\n      }, this), loading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading-spinner\",\n        children: processingProgress.total > 0 ? `Generating audio: ${processingProgress.current} of ${processingProgress.total} items processed` : 'Generating audio...'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 439,\n        columnNumber: 11\n      }, this), loading && processingProgress.total > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${processingProgress.current / processingProgress.total * 100}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 448,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-text\",\n          children: [Math.round(processingProgress.current / processingProgress.total * 100), \"%\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 452,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 447,\n        columnNumber: 11\n      }, this), audioFiles.length > 0 && /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(AudioList, {\n          audioFiles: audioFiles,\n          onDownload: handleDownload\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 460,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"bulk-actions\",\n          children: /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: handleBulkDownload,\n            children: \"Download Selected\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 462,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 461,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 425,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 469,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 423,\n    columnNumber: 5\n  }, this);\n};\n_s(App, \"W7myiXa2O/A062Ay/fjVJBd7PJw=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","parseXlsx","AudioList","Header","Footer","TtsForm","ApiKeyInput","OpenAI","jsxDEV","_jsxDEV","Fragment","_Fragment","apiKey","process","env","REACT_APP_OPENAI_API_KEY","isValidApiKey","key","startsWith","length","storedApiKey","localStorage","getItem","openai","dangerouslyAllowBrowser","App","_s","audioFiles","setAudioFiles","loading","setLoading","error","setError","setApiKey","processingProgress","setProcessingProgress","current","total","handleFileCheckChanged","event","index","checked","detail","prev","newFiles","window","addEventListener","removeEventListener","setItem","handleGenerateAudio","prompt","persona","voice","trim","console","log","response","audio","speech","create","model","input","instructions","undefined","audioBlob","blob","fileName","substring","replace","name","url","err","message","includes","status","handleUploadFiles","files","successCount","failureCount","totalRowsToProcess","file","type","endsWith","data","startRow","toLowerCase","currentProcessed","CHUNK_SIZE","processRow","rowIndex","rowData","rowNumber","openaiClient","promptText","String","allowedVoices","warn","success","processChunk","startIndex","endIndex","handleSuccess","handleFailure","updateProgress","promises","i","processPromise","result","push","Promise","all","handleSuccessCallback","successCountRef","handleFailureCallback","failureCountRef","updateProgressCallback","currentProcessedRef","handleDownload","URL","createObjectURL","a","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","handleBulkDownload","selectedFiles","filter","forEach","indexOf","className","children","_jsxFileName","lineNumber","columnNumber","initialApiKey","onApiKeyChange","onGenerateAudio","onUploadFiles","style","width","Math","round","onDownload","onClick","_c","$RefreshReg$"],"sources":["/Users/gr4yf1r3/testSites/tts-website/src/App.js"],"sourcesContent":["// src/App.js\nimport React, { useState, useEffect } from 'react';\nimport { parseXlsx } from './utils';  // Import parseXlsx from utils.js\nimport AudioList from './components/AudioList';\nimport Header from './components/Header';\nimport Footer from './components/Footer';\nimport TtsForm from './components/TtsForm';\nimport ApiKeyInput from './components/ApiKeyInput';\nimport OpenAI from 'openai';\n\n/**\n * OpenAI API Key from environment variables\n * @type {string}\n */\nconst apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n\n/**\n * Validates if a given API key has the correct format\n * @param {string} key - The API key to validate\n * @returns {boolean} - True if the key is valid, false otherwise\n */\nconst isValidApiKey = (key) => {\n  return key && typeof key === 'string' && key.startsWith('sk-') && key.length > 20;\n};\n\n// Initialize with stored API key if available\nconst storedApiKey = localStorage.getItem('openai_api_key') || apiKey;\n\n/**\n * Initialize OpenAI client - will be re-initialized when API key changes\n */\nlet openai = new OpenAI({\n  apiKey: storedApiKey,\n  dangerouslyAllowBrowser: true // Required for browser usage\n});\n\n/**\n * Main application component\n * Handles text-to-speech generation, excel file processing, and audio file management\n */\nconst App = () => {\n  const [audioFiles, setAudioFiles] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [apiKey, setApiKey] = useState(storedApiKey || '');\n  const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0 });\n\n  // Listen for changes to file checkboxes\n  // Listen for changes to file checkboxes\n  useEffect(() => {\n    const handleFileCheckChanged = (event) => {\n      const { index, checked } = event.detail;\n      setAudioFiles(prev => {\n        const newFiles = [...prev];\n        newFiles[index] = { ...newFiles[index], checked };\n        return newFiles;\n      });\n    };\n\n    window.addEventListener('fileCheckChanged', handleFileCheckChanged);\n    return () => {\n      window.removeEventListener('fileCheckChanged', handleFileCheckChanged);\n    };\n  }, []);\n  \n  // Effect to handle API key changes\n  useEffect(() => {\n    if (apiKey) {\n      // Save to localStorage\n      localStorage.setItem('openai_api_key', apiKey);\n      \n      // Re-initialize OpenAI client with new key\n      openai = new OpenAI({\n        apiKey: apiKey,\n        dangerouslyAllowBrowser: true\n      });\n    }\n  }, [apiKey]);\n\n  /**\n   * Handles audio generation from text prompt using OpenAI API\n   * @param {string} prompt - The text prompt to convert to audio\n   * @param {string} persona - The persona or style for the speech (optional)\n   * @param {string} voice - The voice model to use for speech synthesis\n   */\n  const handleGenerateAudio = async (prompt, persona, voice) => {\n    if (!prompt.trim()) {\n      setError(\"Please enter a prompt text\");\n      return;\n    }\n\n    // First check if API key is available and valid\n    if (!apiKey || !apiKey.startsWith('sk-') || apiKey.length < 20) {\n      setError(\"Please enter a valid OpenAI API key. It should start with 'sk-'\");\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n    \n    try {\n      console.log(`Generating audio for prompt: \"${prompt}\" with voice: ${voice}`);\n      \n      const response = await openai.audio.speech.create({\n        model: \"tts-1\",\n        voice: voice,\n        input: prompt,\n        instructions: persona || undefined,\n      });\n      \n      const audioBlob = await response.blob();\n      const fileName = `${prompt.substring(0, 20).replace(/[^a-zA-Z0-9]/g, '_')}.mp3`;\n      \n      console.log(`Successfully generated audio: ${fileName}`);\n      \n      setAudioFiles(prev => [\n        ...prev, \n        {\n          name: fileName,\n          url: audioBlob,\n          prompt: prompt,\n          checked: false\n        }\n      ]);\n    } catch (err) {\n      console.error('Error generating speech:', err);\n      \n      // More specific error messages based on the error\n      if (err.message && err.message.includes('API key')) {\n        setError(`API key error: ${err.message}. Check your .env file.`);\n      } else if (err.status === 429) {\n        setError(\"Rate limit exceeded. Please try again later.\");\n      } else {\n        setError(`Failed to generate audio: ${err.message || 'Unknown error'}`);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  /**\n   * Handles bulk upload and processing of audio files from selected Excel files\n   * Uses chunking for better performance with large files\n   * @param {FileList} files - The list of Excel files to upload and process\n   */\n  const handleUploadFiles = async (files) => {\n    setLoading(true);\n    setError(null);\n    setProcessingProgress({ current: 0, total: 0 });\n    \n    // First check if API key is available and valid\n    if (!isValidApiKey(apiKey)) {\n      setError(\"OpenAI API key is missing or invalid. Check your .env file.\");\n      setLoading(false);\n      return;\n    }\n    \n    // Track successes and failures\n    let successCount = 0;\n    let failureCount = 0;\n    let totalRowsToProcess = 0;\n    \n    // First, calculate total rows across all files for accurate progress tracking\n    for (const file of files) {\n      if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || \n          file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {\n        try {\n          const data = await parseXlsx(file);\n          if (data && data.length > 0) {\n            // Skip header row if it exists\n            const startRow = data[0] && typeof data[0][0] === 'string' && \n                         (data[0][0].toLowerCase().includes('prompt') || \n                          data[0][0].toLowerCase().includes('text')) ? 1 : 0;\n            totalRowsToProcess += (data.length - startRow);\n          }\n        } catch (err) {\n          console.error('Error parsing XLSX file during count:', err);\n        }\n      }\n    }\n    \n    // Set the total for progress tracking\n    setProcessingProgress({ current: 0, total: totalRowsToProcess });\n    let currentProcessed = 0;\n    \n    // Process each file\n    for (const file of files) {\n      if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || \n          file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {\n        try {\n          console.log(`Processing Excel file: ${file.name}`);\n          const data = await parseXlsx(file);\n          \n          if (!data || data.length === 0) {\n            setError(`File \"${file.name}\" appears to be empty.`);\n            continue;\n          }\n          \n          console.log(`Excel data loaded: ${data.length} rows`);\n          \n          // Skip header row if it exists\n          const startRow = data[0] && typeof data[0][0] === 'string' && \n                         (data[0][0].toLowerCase().includes('prompt') || \n                          data[0][0].toLowerCase().includes('text')) ? 1 : 0;\n          \n          console.log(`Starting processing from row ${startRow+1}`);\n          \n          // Process data in chunks to prevent UI freezing with large files\n          const CHUNK_SIZE = 5; // Process 5 rows at a time\n          \n          /**\n           * Process a single row of data\n           * @param {number} rowIndex - The index of the row in the data array\n           * @param {Object} openaiClient - The OpenAI client instance\n           * @returns {Promise<Object>} - Promise resolving to a result object\n           */\n          const processRow = async (rowIndex, rowData, rowNumber, openaiClient) => {\n            const promptText = rowData[0] ? String(rowData[0]) : '';\n            let voice = rowData[1] || 'alloy'; // Use column 1 for voice if available\n            const instructions = rowData[2] || ''; // Use column 2 for instructions if available\n            \n            // Validate the voice parameter\n            const allowedVoices = ['nova', 'shimmer', 'echo', 'onyx', 'fable', 'alloy', 'ash', 'sage', 'coral'];\n            if (!allowedVoices.includes(voice)) {\n              console.warn(`Invalid voice '${voice}' for row ${rowNumber}. Falling back to default 'alloy'.`);\n              voice = 'alloy';\n            }\n\n            try {\n              console.log(`Processing row ${rowNumber}: \"${promptText.substring(0, 30)}...\" with voice \"${voice}\"`);\n              \n              const response = await openaiClient.audio.speech.create({\n                model: \"tts-1\",\n                voice: voice,\n                input: promptText,\n                instructions: instructions || undefined,\n              });\n              \n              const audioBlob = await response.blob();\n              const fileName = `Row${rowNumber}_${promptText.substring(0, 15).replace(/[^a-zA-Z0-9]/g, '_')}.mp3`;\n              \n              setAudioFiles(prev => [\n                ...prev, \n                {\n                  name: fileName,\n                  url: audioBlob,\n                  prompt: promptText,\n                  checked: false\n                }\n              ]);\n              \n              return { success: true };\n            } catch (err) {\n              console.error(`Error generating speech for row ${rowNumber}:`, err);\n              \n              setAudioFiles(prev => [\n                ...prev, \n                {\n                  name: `Error_Row${rowNumber}.mp3`,\n                  url: null,\n                  prompt: `Error with \"${promptText ? promptText.substring(0, 30) : 'Empty prompt'}...\": ${err.message}`,\n                  checked: false,\n                  error: true\n                }\n              ]);\n              \n              return { success: false, error: err };\n            }\n          };\n          \n          /**\n           * Process a single chunk of data rows\n           * @param {number} startIndex - The starting index of the chunk\n           * @param {number} endIndex - The ending index of the chunk\n           * @param {object} openaiClient - The OpenAI client instance\n           * @param {function} handleSuccess - Function to call on success\n           * @param {function} handleFailure - Function to call on failure\n           * @param {function} updateProgress - Function to update progress\n           * @returns {Promise<Array>} - Promise resolving to array of results\n           */\n          const processChunk = async (\n            startIndex, \n            endIndex, \n            openaiClient, \n            handleSuccess,\n            handleFailure,\n            updateProgress\n          ) => {\n            const promises = [];\n            \n            // Create promises for each row in the chunk\n            for (let i = startIndex; i < endIndex && i < data.length; i++) {\n              if (data[i] && data[i][0]) {\n                const rowNumber = i + 1;\n                \n                // Create a new promise for this row without referencing loop variables in the closure\n                const processPromise = async () => {\n                  const result = await processRow(i, data[i], rowNumber, openaiClient);\n                  \n                  if (result.success) {\n                    handleSuccess(rowNumber);\n                  } else {\n                    handleFailure(rowNumber);\n                  }\n                  \n                  updateProgress();\n                  return result;\n                };\n                \n                promises.push(processPromise());\n              }\n            }\n            \n            // Wait for all promises in this chunk to complete\n            return Promise.all(promises);\n          };\n          \n          // Move function declarations outside the loop and pass variables as parameters\n          const handleSuccessCallback = (rowNumber, successCountRef) => {\n            successCountRef.current++;\n            console.log(`Successfully generated audio for row ${rowNumber}`);\n          };\n\n          const handleFailureCallback = (rowNumber, failureCountRef) => {\n            failureCountRef.current++;\n          };\n\n          const updateProgressCallback = (currentProcessedRef, setProcessingProgress) => {\n            currentProcessedRef.current++;\n            setProcessingProgress(prev => ({ \n              ...prev, \n              current: currentProcessedRef.current\n            }));\n          };\n\n          // Process chunks sequentially to avoid overwhelming the API\n          for (let i = startRow; i < data.length; i += CHUNK_SIZE) {\n            const successCountRef = { current: successCount };\n            const failureCountRef = { current: failureCount };\n            const currentProcessedRef = { current: currentProcessed };\n\n            await processChunk(\n              i, \n              i + CHUNK_SIZE, \n              openai,\n              rowNumber => handleSuccessCallback(rowNumber, successCountRef),\n              rowNumber => handleFailureCallback(rowNumber, failureCountRef),\n              () => updateProgressCallback(currentProcessedRef, setProcessingProgress)\n            );\n\n            // Update the outer variables after processing\n            successCount = successCountRef.current;\n            failureCount = failureCountRef.current;\n            currentProcessed = currentProcessedRef.current;\n          }\n        } catch (err) {\n          console.error('Error parsing XLSX file:', err);\n          setError(`Failed to parse Excel file: ${err.message || 'Unknown error'}`);\n        }\n      } else {\n        setError(`File \"${file.name}\" is not a valid Excel file.`);\n      }\n    }\n    \n    // Show a summary message\n    if (successCount > 0 && failureCount === 0) {\n      setError(null); // Clear any previous errors\n      console.log(`All ${successCount} audio files generated successfully!`);\n    } else if (successCount > 0 && failureCount > 0) {\n      setError(`Generated ${successCount} files successfully, but ${failureCount} failed. Check the list for details.`);\n    } else if (successCount === 0 && failureCount > 0) {\n      setError(`Failed to generate any audio files. Check the console for details.`);\n    }\n    \n    setLoading(false);\n    setProcessingProgress({ current: 0, total: 0 }); // Reset progress\n  };\n\n  /**\n   * Handles downloading of a single audio file\n   * @param {number} index - The index of the audio file in the list\n   */\n  const handleDownload = (index) => {\n    const file = audioFiles[index];\n    if (file && file.url) {\n      try {\n        const url = URL.createObjectURL(file.url);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = file.name;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        console.log(`Downloaded file: ${file.name}`);\n      } catch (err) {\n        console.error('Error downloading file:', err);\n        setError(`Failed to download file: ${err.message}`);\n      }\n    } else if (file) {\n      setError(`Cannot download \"${file.name}\" - no audio data available`);\n    }\n  };\n\n  /**\n   * Handles bulk downloading of selected audio files\n   */\n  const handleBulkDownload = () => {\n    const selectedFiles = audioFiles.filter(file => file.checked);\n    if (selectedFiles.length === 0) {\n      // If none selected, download all\n      audioFiles.forEach((file, index) => handleDownload(index));\n    } else {\n      // Download only selected\n      selectedFiles.forEach(file => {\n        const index = audioFiles.indexOf(file);\n        if (index !== -1) handleDownload(index);\n      });\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <Header />\n      <main>\n        <ApiKeyInput \n          initialApiKey={apiKey} \n          onApiKeyChange={setApiKey} \n        />\n        \n        <TtsForm \n          onGenerateAudio={handleGenerateAudio} \n          onUploadFiles={handleUploadFiles} \n        />\n        \n        {error && <div className=\"error-message\">{error}</div>}\n        \n        {loading && (\n          <div className=\"loading-spinner\">\n            {processingProgress.total > 0 \n              ? `Generating audio: ${processingProgress.current} of ${processingProgress.total} items processed` \n              : 'Generating audio...'}\n          </div>\n        )}\n        \n        {loading && processingProgress.total > 0 && (\n          <div className=\"progress-bar\">\n            <div \n              className=\"progress-fill\" \n              style={{ width: `${(processingProgress.current / processingProgress.total) * 100}%` }}\n            />\n            <div className=\"progress-text\">\n              {Math.round((processingProgress.current / processingProgress.total) * 100)}%\n            </div>\n          </div>\n        )}\n        \n        {audioFiles.length > 0 && (\n          <>\n            <AudioList audioFiles={audioFiles} onDownload={handleDownload} />\n            <div className=\"bulk-actions\">\n              <button onClick={handleBulkDownload}>\n                Download Selected\n              </button>\n            </div>\n          </>\n        )}\n      </main>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}